{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import { readFile } from \"fs/promises\";\n\nimport type { OpenAPI3 } from \"openapi-typescript\";\nimport openapiTS from \"openapi-typescript\";\nimport { z } from \"zod\";\n\ntype ReadSpecFileOptions = {\n  readonly specFile?: undefined | string;\n  readonly host?: undefined | string;\n  readonly email?: undefined | string;\n  readonly password?: undefined | string;\n};\n\nconst DirectusAuthResponse = z.object({\n  data: z.object({\n    access_token: z.string(),\n    expires: z.number().int(),\n    refresh_token: z.string(),\n  }),\n});\n\nexport const readSpecFile = async (\n  options: ReadSpecFileOptions,\n): Promise<unknown> => {\n  if (typeof options.specFile === `string`) {\n    return JSON.parse(\n      await readFile(options.specFile, { encoding: `utf-8` }),\n    ) as unknown;\n  }\n\n  if (typeof options.host !== `string`) {\n    throw new Error(`Either inputFile or inputUrl must be specified`);\n  }\n  if (typeof options.email !== `string`) {\n    throw new Error(`email must be specified`);\n  }\n  if (typeof options.password !== `string`) {\n    throw new Error(`password must be specified`);\n  }\n\n  const {\n    data: { access_token },\n  } = await fetch(new URL(`/auth/login`, options.host), {\n    body: JSON.stringify({\n      email: options.email,\n      password: options.password,\n    }),\n    headers: {\n      \"Content-Type\": `application/json`,\n    },\n    method: `POST`,\n  })\n    .then((response) => response.json())\n    .then((json) => DirectusAuthResponse.parse(json));\n\n  return (await fetch(new URL(`/server/specs/oas`, options.host), {\n    headers: {\n      \"Authorization\": `Bearer ${access_token}`,\n      \"Content-Type\": `application/json`,\n    },\n  }).then((response) => response.json())) as unknown;\n};\n\ntype GenerateTypeScriptOptions = {\n  readonly includeSystemCollections?: boolean;\n  readonly typeName: string;\n};\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\nexport const generateTypeScript = async (\n  spec: OpenAPI3,\n  { includeSystemCollections, typeName }: GenerateTypeScriptOptions,\n): Promise<string> => {\n  if (!validIdentifier.test(typeName)) {\n    throw new Error(`Invalid type name: ${typeName}`);\n  }\n\n  let source = await openapiTS(spec);\n\n  source += `\\n\\nexport type ${typeName} = {\\n`;\n\n  // Keep a record of discovered collections to avoid duplicates\n  const collections: Record<string, string> = {};\n\n  if (spec.paths) {\n    for (const [path, pathItem] of Object.entries(spec.paths)) {\n      const collectionPathPattern = /^\\/items\\/(?<collection>[a-zA-Z0-9_]+)$/;\n      const collection =\n        collectionPathPattern.exec(path)?.groups?.[`collection`];\n      if (typeof collection !== `string` || collection.length === 0) {\n        continue;\n      }\n      if (\n        `get` in pathItem &&\n        `responses` in pathItem.get &&\n        `200` in pathItem.get.responses &&\n        `content` in pathItem.get.responses[`200`] &&\n        `application/json` in pathItem.get.responses[`200`].content &&\n        `schema` in pathItem.get.responses[`200`].content[`application/json`] &&\n        `properties` in\n          pathItem.get.responses[`200`].content[`application/json`].schema &&\n        `data` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties &&\n        `items` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`] &&\n        `$ref` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`].items\n      ) {\n        const $ref =\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`].items.$ref;\n        const refPattern = /^#\\/components\\/schemas\\/(?<ref>[a-zA-Z0-9_]+)$/;\n        const ref = refPattern.exec($ref)?.groups?.[`ref`];\n        if (typeof ref !== `string` || ref.length === 0) {\n          continue;\n        }\n        // Instead of adding directly to source, store in collections\n        if (!collections[collection]) {\n          collections[collection] = `components[\"schemas\"][\"${ref}\"][]`;\n        }\n      }\n    }\n  }\n\n  // Add directus system collections if requested\n  if (spec.components && spec.components.schemas && includeSystemCollections) {\n    for (const [schema_key, schema_value] of Object.entries(\n      spec.components.schemas,\n    )) {\n      const x_collection = (schema_value as Record<string, unknown>)[\n        `x-collection`\n      ] as string | undefined;\n      if (typeof x_collection === `string` && x_collection.length > 0) {\n        // Only add if not already present\n        if (!collections[x_collection]) {\n          collections[x_collection] = `components[\"schemas\"][\"${schema_key}\"]`;\n        }\n      }\n    }\n  }\n\n  // After gathering all collections, write them out once\n  for (const [collectionName, typeDef] of Object.entries(collections)) {\n    source += `  ${collectionName}: ${typeDef};\\n`;\n  }\n\n  source += `};\\n`;\n\n  return source;\n};\n"],
  "mappings": "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",
  "names": []
}
