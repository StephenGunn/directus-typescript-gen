{
  "version": 3,
  "sources": ["../src/cli.ts", "../src/index.ts"],
  "sourcesContent": ["#!/usr/bin/env node\n\nimport { writeFile } from \"fs/promises\";\nimport { resolve } from \"path\";\n\nimport yargs from \"yargs\";\nimport type { OpenAPI3 } from \"openapi-typescript\";\n\nimport { generateTypeScript, readSpecFile } from \".\";\n\nconst main = async (): Promise<void> => {\n  const argv = await yargs.options({\n    email: {\n      alias: `e`,\n      description: `Email address`,\n      type: `string`,\n    },\n    host: {\n      alias: `h`,\n      description: `Remote host`,\n      type: `string`,\n    },\n    includeSystemCollections: {\n      alias: `s`,\n      default: false,\n      description: `Include system collections`,\n      type: `boolean`,\n    },\n    outFile: {\n      alias: `o`,\n      description: `Output file`,\n      type: `string`,\n    },\n    password: {\n      alias: `p`,\n      description: `Password`,\n      type: `string`,\n    },\n    specFile: {\n      alias: `i`,\n      description: `Input spec file`,\n      type: `string`,\n    },\n    typeName: {\n      alias: `t`,\n      default: `Schema`,\n      description: `Type name`,\n      type: `string`,\n    },\n  }).argv;\n\n  const spec = await readSpecFile(argv);\n\n  const ts = await generateTypeScript(spec as OpenAPI3, {\n    includeSystemCollections: argv.includeSystemCollections,\n    typeName: argv.typeName,\n  });\n\n  if (typeof argv.outFile === `string`) {\n    await writeFile(resolve(process.cwd(), argv.outFile), ts, {\n      encoding: `utf-8`,\n    });\n  } else {\n    console.log(ts);\n  }\n};\n\nmain().catch((error) => {\n  console.error(error);\n  process.exit(1);\n});\n", "import { readFile } from \"fs/promises\";\n\nimport type { OpenAPI3 } from \"openapi-typescript\";\nimport openapiTS from \"openapi-typescript\";\nimport { z } from \"zod\";\n\ntype ReadSpecFileOptions = {\n  readonly specFile?: undefined | string;\n  readonly host?: undefined | string;\n  readonly email?: undefined | string;\n  readonly password?: undefined | string;\n};\n\nconst DirectusAuthResponse = z.object({\n  data: z.object({\n    access_token: z.string(),\n    expires: z.number().int(),\n    refresh_token: z.string(),\n  }),\n});\n\nexport const readSpecFile = async (\n  options: ReadSpecFileOptions,\n): Promise<unknown> => {\n  if (typeof options.specFile === `string`) {\n    return JSON.parse(\n      await readFile(options.specFile, { encoding: `utf-8` }),\n    ) as unknown;\n  }\n\n  if (typeof options.host !== `string`) {\n    throw new Error(`Either inputFile or inputUrl must be specified`);\n  }\n  if (typeof options.email !== `string`) {\n    throw new Error(`email must be specified`);\n  }\n  if (typeof options.password !== `string`) {\n    throw new Error(`password must be specified`);\n  }\n\n  const {\n    data: { access_token },\n  } = await fetch(new URL(`/auth/login`, options.host), {\n    body: JSON.stringify({\n      email: options.email,\n      password: options.password,\n    }),\n    headers: {\n      \"Content-Type\": `application/json`,\n    },\n    method: `POST`,\n  })\n    .then((response) => response.json())\n    .then((json) => DirectusAuthResponse.parse(json));\n\n  return (await fetch(new URL(`/server/specs/oas`, options.host), {\n    headers: {\n      \"Authorization\": `Bearer ${access_token}`,\n      \"Content-Type\": `application/json`,\n    },\n  }).then((response) => response.json())) as unknown;\n};\n\ntype GenerateTypeScriptOptions = {\n  readonly includeSystemCollections?: boolean;\n  readonly typeName: string;\n};\n\nconst validIdentifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\nexport const generateTypeScript = async (\n  spec: OpenAPI3,\n  { includeSystemCollections, typeName }: GenerateTypeScriptOptions,\n): Promise<string> => {\n  if (!validIdentifier.test(typeName)) {\n    throw new Error(`Invalid type name: ${typeName}`);\n  }\n\n  let source = await openapiTS(spec);\n\n  source += `\\n\\nexport type ${typeName} = {\\n`;\n\n  // Keep a record of discovered collections to avoid duplicates\n  const collections: Record<string, string> = {};\n\n  if (spec.paths) {\n    for (const [path, pathItem] of Object.entries(spec.paths)) {\n      const collectionPathPattern = /^\\/items\\/(?<collection>[a-zA-Z0-9_]+)$/;\n      const collection =\n        collectionPathPattern.exec(path)?.groups?.[`collection`];\n      if (typeof collection !== `string` || collection.length === 0) {\n        continue;\n      }\n      if (\n        `get` in pathItem &&\n        `responses` in pathItem.get &&\n        `200` in pathItem.get.responses &&\n        `content` in pathItem.get.responses[`200`] &&\n        `application/json` in pathItem.get.responses[`200`].content &&\n        `schema` in pathItem.get.responses[`200`].content[`application/json`] &&\n        `properties` in\n          pathItem.get.responses[`200`].content[`application/json`].schema &&\n        `data` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties &&\n        `items` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`] &&\n        `$ref` in\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`].items\n      ) {\n        const $ref =\n          pathItem.get.responses[`200`].content[`application/json`].schema\n            .properties[`data`].items.$ref;\n        const refPattern = /^#\\/components\\/schemas\\/(?<ref>[a-zA-Z0-9_]+)$/;\n        const ref = refPattern.exec($ref)?.groups?.[`ref`];\n        if (typeof ref !== `string` || ref.length === 0) {\n          continue;\n        }\n        // Instead of adding directly to source, store in collections\n        if (!collections[collection]) {\n          collections[collection] = `components[\"schemas\"][\"${ref}\"][]`;\n        }\n      }\n    }\n  }\n\n  // fixing relationships\n  const relationshipPathPattern = /^\\/relations\\/(?<relation>[a-zA-Z0-9_]+)$/;\n  for (const [path, pathItem] of Object.entries(spec.paths ?? {})) {\n    const relation = relationshipPathPattern.exec(path)?.groups?.[`relation`];\n    if (typeof relation !== `string` || relation.length === 0) {\n      continue;\n    }\n    if (\n      `get` in pathItem &&\n      `responses` in pathItem.get &&\n      `200` in pathItem.get.responses &&\n      `content` in pathItem.get.responses[`200`] &&\n      `application/json` in pathItem.get.responses[`200`].content &&\n      `schema` in pathItem.get.responses[`200`].content[`application/json`] &&\n      `properties` in\n        pathItem.get.responses[`200`].content[`application/json`].schema &&\n      `data` in\n        pathItem.get.responses[`200`].content[`application/json`].schema\n          .properties &&\n      `items` in\n        pathItem.get.responses[`200`].content[`application/json`].schema\n          .properties[`data`] &&\n      `$ref` in\n        pathItem.get.responses[`200`].content[`application/json`].schema\n          .properties[`data`].items\n    ) {\n      const $ref =\n        pathItem.get.responses[`200`].content[`application/json`].schema\n          .properties[`data`].items.$ref;\n      const refPattern = /^#\\/components\\/schemas\\/(?<ref>[a-zA-Z0-9_]+)$/;\n      const ref = refPattern.exec($ref)?.groups?.[`ref`];\n      if (typeof ref !== `string` || ref.length === 0) {\n        continue;\n      }\n      // Add relationship to collections\n      if (!collections[relation]) {\n        collections[relation] = `components[\"schemas\"][\"${ref}\"][]`;\n      }\n    }\n  }\n\n  // Add directus system collections if requested\n  if (spec.components && spec.components.schemas && includeSystemCollections) {\n    for (const [schema_key, schema_value] of Object.entries(\n      spec.components.schemas,\n    )) {\n      const x_collection = (schema_value as Record<string, unknown>)[\n        `x-collection`\n      ] as string | undefined;\n      if (typeof x_collection === `string` && x_collection.length > 0) {\n        // Only add if not already present\n        if (!collections[x_collection]) {\n          collections[x_collection] = `components[\"schemas\"][\"${schema_key}\"]`;\n        }\n      }\n    }\n  }\n\n  // After gathering all collections, write them out once\n  for (const [collectionName, typeDef] of Object.entries(collections)) {\n    source += `  ${collectionName}: ${typeDef};\\n`;\n  }\n\n  source += `};\\n`;\n\n  const toPascalCase = (str: string): string =>\n    str\n      .replace(/[_\\- ]+/g, ` `)\n      .split(` `)\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(``);\n\n  // Iterate over each collection to create individual export types\n  for (const [collectionName, typeDef] of Object.entries(collections)) {\n    const pascalCaseName = toPascalCase(collectionName);\n    source += `export type ${pascalCaseName} = ${typeDef};\\n`;\n  }\n\n  return source;\n};\n"],
  "mappings": "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",
  "names": ["import_promises", "openapiTS", "yargs"]
}
